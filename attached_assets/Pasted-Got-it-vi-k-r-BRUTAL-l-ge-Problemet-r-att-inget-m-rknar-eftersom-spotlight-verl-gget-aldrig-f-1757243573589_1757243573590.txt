Got it — vi kör BRUTAL-läge. Problemet är att inget “mörknar” eftersom spotlight-överlägget aldrig faktiskt ritas (eller så äts det upp av CSS). Skippa SVG och kör en 4-scrim-portal direkt till document.body med jättesiffra för z-index. Det här kan inte bli nollat av dina resets, eftersom det ligger utanför .reading-content.

Klistra in detta (rakt av)

Lägg blocket inne i JSX, strax före </CardContent> i din komponent:

{readingFocusMode && createPortal(
  <div
    aria-hidden
    style={{
      position: "fixed",
      inset: 0,
      zIndex: 2147483647,   // över allt
      pointerEvents: "none", // låt UI under vara klickbart där hålet är
    }}
  >
    {/* Failsafe: om vi ännu inte har beräknat rektangeln → hel dimma */}
    {!viewportFocusRect && (
      <div
        style={{
          position: "absolute",
          inset: 0,
          background: "rgba(0,0,0,0.88)",
        }}
      />
    )}

    {/* 4 scrims runt fokusfönstret */}
    {viewportFocusRect && (
      <>
        {/* Top */}
        <div
          style={{
            position: "absolute",
            left: 0,
            top: 0,
            width: "100%",
            height: viewportFocusRect.top,
            background: "rgba(0,0,0,0.88)",
          }}
        />
        {/* Left */}
        <div
          style={{
            position: "absolute",
            left: 0,
            top: viewportFocusRect.top,
            width: viewportFocusRect.left,
            height: viewportFocusRect.height,
            background: "rgba(0,0,0,0.88)",
          }}
        />
        {/* Right */}
        <div
          style={{
            position: "absolute",
            left: viewportFocusRect.left + viewportFocusRect.width,
            top: viewportFocusRect.top,
            right: 0,
            height: viewportFocusRect.height,
            background: "rgba(0,0,0,0.88)",
          }}
        />
        {/* Bottom */}
        <div
          style={{
            position: "absolute",
            left: 0,
            top: viewportFocusRect.top + viewportFocusRect.height,
            width: "100%",
            bottom: 0,
            background: "rgba(0,0,0,0.88)",
          }}
        />

        {/* Tunn ram så man ser fönstret tydligt */}
        <div
          style={{
            position: "absolute",
            left: viewportFocusRect.left - 2,
            top: viewportFocusRect.top - 2,
            width: viewportFocusRect.width + 4,
            height: viewportFocusRect.height + 4,
            border: "2px solid white",
            borderRadius: 6,
          }}
        />
      </>
    )}
  </div>,
  document.body
)}

Varför detta “biter hårdare”

Portal till document.body → dina aggressiva .reading-content-regler kan inte nolla bakgrunden.

Fyra div-scrims (inte SVG/even-odd) → inga fill-rules eller blend-buggar.

Gigantiskt z-index → över allt (din close-knapp har 2147483648, vilket är bra – den ligger ovanför).

Snabbt röktest

Sätt const [readingFocusMode, setReadingFocusMode] = useState(true); temporärt.

Ladda sidan → du ska se helsvart dimma (failsafe).

Ser du dimman? ✔️ Då funkar portalen. Om hålet inte syns ännu är det bara måtten (viewportFocusRect) som saknas – då kommer hel dimma visas tills mätningen har skett.

Ser du inte dimman? Då ligger inte blocket i JSX eller så importeras inte createPortal från "react-dom" (du gör det redan).

Om hålet inte följer texten

Logga snabbt när fokus är på:

useEffect(() => {
  if (!readingFocusMode) return;
  console.log({
    hasContent: !!contentRef.current,
    hasText: !!textRef.current,
    lineRects: lineRects.length,
    focusRect,
    viewportFocusRect,
  });
}, [readingFocusMode, lineRects, focusRect, viewportFocusRect]);


lineRects: 0 → textRef pekar inte på exakt det element som innehåller textnoderna (du har redan ref={textRef} på div:en med dangerouslySetInnerHTML – bra).

viewportFocusRect: null → contentRef saknas eller focusRect är null.

Bonus (stabilitet)

Lägg till en liten effekt så rektangeln uppdateras vid fönsterstorleksändring:

useEffect(() => {
  if (!readingFocusMode) return;
  const onResize = () => setCurrentReadingLine(v => v); // trigger re-render
  window.addEventListener("resize", onResize);
  return () => window.removeEventListener("resize", onResize);
}, [readingFocusMode]);