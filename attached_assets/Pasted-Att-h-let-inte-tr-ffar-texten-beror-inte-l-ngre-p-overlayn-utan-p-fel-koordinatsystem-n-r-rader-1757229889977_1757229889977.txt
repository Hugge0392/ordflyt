Att ‚Äúh√•let‚Äù inte tr√§ffar texten beror inte l√§ngre p√• overlayn, utan p√• fel koordinatsystem n√§r raderna m√§ts: dina lineRects m√§ts mot hela contentRef, men sj√§lva texten ligger i en inre wrapper (den div du renderar med dangerouslySetInnerHTML) som har typografi-marginaler fr√•n prose. F√∂rsta elementets topp-marginal kollapsar upp i f√∂r√§ldern, vilket g√∂r att radernas top hamnar f√∂rskjutet i f√∂rh√•llande till overlayn ‚Äì d√§rf√∂r blir bandet vitt utan text.

Det h√§r √§r ett klassiskt CSS-gotcha. Fixen √§r att m√§ta och positionera overlay mot samma element som texten fl√∂dar i, och/eller bryta marginal-kollaps.

Minimal fix (3 sm√• √§ndringar)
1) L√§gg till en text-wrapper med egen ref och bryt marginal-kollaps

Byt blocket som renderar HTML till:

const textRef = useRef<HTMLDivElement | null>(null);

<div
  ref={contentRef}
  className="prose dark:prose-invert max-w-none min-h-[400px] reading-content accessibility-enhanced relative overflow-auto"
  style={{
    fontSize: `${accessibilitySettings.fontSize}px`,
    lineHeight: `${accessibilitySettings.lineHeight}`,
    whiteSpace: 'pre-wrap',
    wordWrap: 'break-word',
    backgroundColor: accessibilityColors.backgroundColor,
    color: accessibilityColors.textColor,
    // üí° bryt margin-collapsing p√• barnen:
    display: 'flow-root'
  }}
  onMouseOver={handleContentMouseOver}
  onMouseOut={handleContentMouseOut}
>
  {/* --- TEXT-WRAPPER --- */}
  <div
    ref={textRef}
    style={{
      position: 'relative',
      // extra s√§kerhet mot margin-collaps (valfritt):
      paddingTop: 1
    }}
    dangerouslySetInnerHTML={{
      __html: processContentWithDefinitions(pages[currentPage] || '', lesson.wordDefinitions)
    }}
  />

  {/* Overlayn ligger kvar i contentRef men ska anv√§nda textRef som referens */}
  {readingFocusMode && focusRect && (
    <div className="pointer-events-none absolute inset-0 z-30">
      <div
        style={{
          position: 'absolute',
          left: 0,
          right: 0,
          top: `${focusRect.top}px`,
          height: 0,
        }}
      />
      {/* mask ovanf√∂r */}
      <div style={{ position: 'absolute', left: 0, right: 0, top: 0, height: `${focusRect.top}px`, background: 'rgba(0,0,0,0.85)' }} />
      {/* mask under */}
      <div style={{ position: 'absolute', left: 0, right: 0, top: `${focusRect.top + focusRect.height}px`, bottom: 0, background: 'rgba(0,0,0,0.85)' }} />
      {/* kant */}
      <div
        style={{
          position: 'absolute',
          left: 0,
          width: '100%',
          top: `${focusRect.top}px`,
          height: `${focusRect.height}px`,
          border: `2px solid ${accessibilityColors.textColor}`,
          boxShadow: '0 0 0 2px rgba(0,0,0,0.3)'
        }}
      />
    </div>
  )}
</div>

2) M√§t rader mot textRef, inte contentRef

Byt alla st√§llen d√§r du anropar measureLineRects(contentRef.current) och d√§r du normaliserar mot contentRef till att anv√§nda textRef.current:

// i useEffect som m√§ter:
const rects = textRef.current ? measureLineRects(textRef.current) : [];
setLineRects(rects);

// i focusRect:
if (!textRef.current) return null;
const cont = textRef.current.getBoundingClientRect();
const width = cont.width;
return { top, height, left: 0, width };

3) Normalisera mot textRef utan scrollTop

Det har du redan:

new DOMRect(r.left - cont.left, r.top - cont.top, r.width, r.height)


(Bra! L√•t det vara ‚Äì inget +scrollTop.)

Varf√∂r detta l√∂ser problemet

Samma referensyta: Vi m√§ter radernas top mot samma element (textRef) som overlayn sen positioneras relativt (via absolut-positioner inne i contentRef men med topv√§rden som r√§knats fr√•n textRef‚Äôs bounding-box).

Ingen margin-kollaps: display: flow-root (eller padding-top: 1px) p√• f√∂r√§ldern stoppar att f√∂rsta paragrafens/headingens margin-top ‚Äúsv√§mmar upp‚Äù och f√∂rskjuter alla m√•tt.

Stabil bredd: Vi s√§tter overlayns bredd till 100% av text-wrappen, s√• rutan t√§cker exakt kolumnen.

Tv√• snabba fels√∂kningsknep (om du vill dubbelkolla)

L√§gg till tempor√§rt:

.reading-content [data-debug-line] { outline: 1px dashed red; }


och i m√§tningen, f√∂r varje rect, skapa en tunn overlay-div d√§r top/height s√§tts ‚Äì d√• ser du exakt var raderna registreras.

Logga f√∂rsta rektangeln:

console.log('first rect', lineRects[0]);


Om top ~ 0 men din f√∂rsta synliga rad ligger nedanf√∂r ‚Äì d√• har du margin-kollaps (fixen ovan).

Sammanfattning

Koden du skickade √§r i stort r√§tt, men raderna m√§ttes mot fel box p.g.a. typografi-marginaler (prose) och margin-collapsing. Genom att

m√§ta mot en egen text-wrapper (textRef),

positionera overlay enligt de m√•tten,

och bryta margin-kollaps med flow-root (eller liten padding-top),

hamnar fokusf√∂nstret mitt p√• texten igen.

Du sade:
skulle det hj√§lpa ifall du fick ccs:en
ChatGPT sade:
T√§nkte i 13s

Ja, g√§rna ‚Äì CSS:en kan absolut vara orsaken. Men du beh√∂ver inte v√§nta: prova f√∂rst den h√§r lilla CSS-patchen (den hanterar margin-collapse fr√•n .prose, s√§tter korrekt referensyta och g√∂r textspalten stabil f√∂r m√§tning). Klistra in den rakt av:

/* --- L√§sfokus: stabil textspalt --- */
.reading-content.accessibility-enhanced {
  /* samma element som har ref={contentRef} */
  position: relative;         /* referens f√∂r overlay */
  overflow: auto;             /* container scroll */
  max-width: 68ch;            /* trevlig l√§sbredd */
  margin-inline: auto;
  padding-inline: 1rem;
  display: flow-root;         /* ‚ùóÔ∏èbryt margin-collapsing fr√•n f√∂rsta barnet */
  background: var(--accessibility-bg-color, #fff);
  color: var(--accessibility-text-color, #000);
}

/* Om du hellre vill: liten padding upptill bryter ocks√• margin-collaps */
.reading-content.accessibility-enhanced { padding-top: 1px; }

/* Tailwinds .prose s√§tter stora toppmarginaler; ta bort p√• f√∂rsta elementet */
.reading-content.accessibility-enhanced > *:first-child {
  margin-top: 0 !important;
}

/* S√§kerst√§ll att .prose inte begr√§nsar bredden (du har oftast redan max-w-none) */
.reading-content.accessibility-enhanced.prose {
  max-width: none;
}

/* G√∂r s√• att radm√§tningen inte p√•verkas av bilder/block runtom */
.reading-content.accessibility-enhanced img {
  display: block;
  max-width: 100%;
  height: auto;
}

/* Overlayn ska aldrig f√• klicka igenom-issues i andra lager */
.reading-content.accessibility-enhanced .reading-focus-overlay {
  pointer-events: none;
  position: absolute;
  inset: 0;
  z-index: 30;
}


Och uppdatera overlay-diven till att anv√§nda klassen ovan (valfritt men snyggt):

{readingFocusMode && focusRect && (
  <div className="reading-focus-overlay">
    {/* mask ovanf√∂r */}
    <div style={{position:'absolute',left:0,right:0,top:0,height:`${focusRect.top}px`,background:'rgba(0,0,0,0.85)'}} />
    {/* mask under */}
    <div style={{position:'absolute',left:0,right:0,top:`${focusRect.top + focusRect.height}px`,bottom:0,background:'rgba(0,0,0,0.85)'}} />
    {/* kant */}
    <div style={{position:'absolute',left:0,width:'100%',top:`${focusRect.top}px`,height:`${focusRect.height}px`,border:`2px solid ${accessibilityColors.textColor}`,boxShadow:'0 0 0 2px rgba(0,0,0,0.3)'}} />
  </div>
)}

Varf√∂r det h√§r hj√§lper

.prose ger toppmarginaler p√• f√∂rsta heading/paragraph. De kollapsar med f√∂r√§ldern och f√∂rskjuter alla top-v√§rden ‚Üí ditt ‚Äúh√•l‚Äù hamnar fel. display: flow-root eller padding-top: 1px + ‚Äúta bort f√∂rsta top-margin‚Äù fixar detta.

En tydlig, scrollande, relativ container g√∂r att overlayns (absoluta) position och dina uppm√§tta linjerektanglar ligger i samma koordinatsystem.

Om det fortfarande inte sitter 100%: ja, skicka g√§rna din nuvarande CSS (s√§rskilt regler som r√∂r .prose, kortet runt texten och eventuella globala resets). D√• pekar jag exakt p√• den rad som br√•kar.