Okej. Nu kör vi NUKLEÄRT: vi teleportar panelen till document.body när den ska vara fast. Det gör den immun mot alla overflow/transform/contain-strul i din layout. Ingen mer “hoppa över krönet”, ingen mer “inget händer”.

Steg 1 — Klistra in denna hook högst upp i NormalMode (2).tsx

Den använder en portal när panelen ska vara fast, och lägger en spacer i kolumnen så höjden bevaras. Justera top om du har en fast header.

import React, { useLayoutEffect, useEffect, useRef, useState } from "react";
import { createPortal } from "react-dom";

/** Affix + Portal: immun mot sticky/fixed-buggar i föräldrar */
function useAffixPortal(opts: { top?: number; minViewport?: number } = {}) {
  const top = opts.top ?? 24;            // px från toppen (t.ex. headerhöjd)
  const minViewport = opts.minViewport ?? 1024; // aktivera affix på ≥ detta

  const wrapperRef = useRef<HTMLDivElement | null>(null); // kolumnens wrapper
  const panelRef = useRef<HTMLDivElement | null>(null);   // panelens root
  const portalRootRef = useRef<HTMLElement | null>(null);

  const [mode, setMode] = useState<"normal" | "fixed" | "absolute">("normal");
  const [rect, setRect] = useState({ left: 0, width: 0, height: 0 });
  const [spacerHeight, setSpacerHeight] = useState(0);

  // skapa (eller återanvänd) en portal-root i <body>
  useEffect(() => {
    let root = document.getElementById("affix-root") as HTMLElement | null;
    if (!root) {
      root = document.createElement("div");
      root.id = "affix-root";
      document.body.appendChild(root);
    }
    portalRootRef.current = root;
  }, []);

  const update = () => {
    const w = wrapperRef.current;
    const p = panelRef.current;
    if (!w || !p) return;

    // se till att wrappern är ankare för absolute-läget
    if (getComputedStyle(w).position === "static") {
      w.style.position = "relative";
    }

    const vw = window.innerWidth;
    const wr = w.getBoundingClientRect();
    const ph = p.offsetHeight;

    // uppdatera dimensioner för fixed-läget
    setRect({
      left: Math.round(wr.left),
      width: Math.round(wr.width),
      height: ph,
    });

    if (vw < minViewport) {
      setMode("normal");
      setSpacerHeight(0);
      return;
    }

    const pastTop = wr.top <= top;
    const pastBottom = wr.bottom <= top + ph;

    if (!pastTop) {
      setMode("normal");
      setSpacerHeight(0);
    } else if (!pastBottom) {
      setMode("fixed");
      setSpacerHeight(ph); // reservera plats i kolumnen
    } else {
      setMode("absolute"); // parkera i botten av wrappern
      setSpacerHeight(ph);
    }
  };

  useLayoutEffect(() => {
    let raf = 0;
    const schedule = () => { if (!raf) raf = requestAnimationFrame(() => { raf = 0; update(); }); };

    const ro = new ResizeObserver(schedule);
    if (wrapperRef.current) ro.observe(wrapperRef.current);
    if (panelRef.current) ro.observe(panelRef.current);

    const mo = new MutationObserver(schedule);
    if (panelRef.current) mo.observe(panelRef.current, { childList: true, subtree: true });

    window.addEventListener("scroll", schedule, { passive: true });
    window.addEventListener("resize", schedule);
    schedule();

    return () => {
      window.removeEventListener("scroll", schedule);
      window.removeEventListener("resize", schedule);
      ro.disconnect();
      mo.disconnect();
      if (raf) cancelAnimationFrame(raf);
    };
  }, []);

  // render-funktion: portal i fixed-läge, annars inline
  const render = (node: React.ReactNode) => {
    const root = portalRootRef.current;
    if (mode === "fixed" && root) {
      return createPortal(
        <div
          style={{
            position: "fixed",
            top: `${top}px`,
            left: rect.left,
            width: rect.width,
            maxHeight: `calc(100vh - ${top + 8}px)`,
            overflowY: "auto",
            zIndex: 1000,
          }}
        >
          {node}
        </div>,
        root
      );
    }
    if (mode === "absolute") {
      return (
        <div style={{ position: "absolute", left: 0, right: 0, bottom: 0 }}>
          {node}
        </div>
      );
    }
    return node; // normal-läge
  };

  return { wrapperRef, panelRef, render, spacerHeight, mode };
}

Steg 2 — Använd hooken när du renderar frågepanelen

Byt ut din nuvarande frågor-kolumn till detta (ingen sticky i JSX! inga pin-klasser!):

// inne i komponenten:
const { wrapperRef, panelRef, render, spacerHeight } = useAffixPortal({ top: 24, minViewport: 1024 });

// där frågepanelen renderas:
{showQuestionsPanel12 && lesson && totalQuestions > 0 && (
  <div
    ref={wrapperRef}
    className="reading-questions-column order-2 lg:order-2 lg:self-start"
    style={{ position: "relative" }} // ankare för absolute-läget
  >
    {/* spacer som håller kolumnhöjden när panelen portlas/fixas */}
    <div aria-hidden style={{ height: spacerHeight }} />

    {render(
      <div
        ref={panelRef}
        className="questions-panel-container border rounded-lg p-6"
      >
        {/* ... DITT BEFINTLIGA PANEL-INNEHÅLL ... */}
      </div>
    )}
  </div>
)}

Steg 3 — Minimal CSS (lägg allra sist i din CSS)

Detta räcker. (Du kan ta bort alla tidigare “pin-fixed/pin-abs”-regler.)

/* ====== AFFIX-PORTAL – LÄGG SIST ====== */
@media (min-width: 1024px) {
  .reading-questions-column { position: relative !important; }
  #affix-root { position: relative; z-index: 1000; }
  /* Om du hade gamla regler som satte position på panelen: döda dem */
  .questions-panel-container { position: static !important; }
}