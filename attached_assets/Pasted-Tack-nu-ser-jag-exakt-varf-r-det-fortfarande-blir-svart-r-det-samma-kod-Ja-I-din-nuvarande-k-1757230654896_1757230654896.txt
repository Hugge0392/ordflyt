Tack — nu ser jag exakt varför det fortfarande blir svart.

Är det samma kod?

Ja. I din nuvarande kod mäts raderna fortfarande med

function measureLineRects(container: HTMLElement): DOMRect[]


och du anropar den med:

const rects = measureLineRects(textRef.current);


Det var just detta jag bad dig ändra förra gången. Overlayn ritas relativt contentRef (ytterdiven), men rektanglarna mäts relativt textRef (innerdiven) och dessutom utan att lägga till container-scroll — därför hamnar “hålet” fel och masken täcker allt.

Gör så här (3 små ändringar)
1) Byt ut mätfunktionen

Byt ut din measureLineRects helt mot denna version som tar både text-elementet och container-elementet, och normaliserar till container-koordinater inkl. scrollTop/scrollLeft:

function measureLineRects(textEl: HTMLElement, containerEl: HTMLElement): DOMRect[] {
  if (!textEl || !containerEl) return [];

  const rects: DOMRect[] = [];
  const textNodes = getAllTextNodes(textEl);
  if (!textNodes.length) return [];

  const range = document.createRange();

  for (const tn of textNodes) {
    const len = tn.length;
    let lastTop: number | null = null;

    for (let i = 0; i < len; i++) {
      range.setStart(tn, i);
      range.setEnd(tn, i + 1);

      const clientRects = range.getClientRects();
      if (!clientRects?.length) continue;

      const r = clientRects[0];
      if (r.width === 0 || r.height === 0) continue;

      if (lastTop === null || Math.abs(r.top - lastTop) > 0.5) {
        rects.push(r);
        lastTop = r.top;
      } else {
        const prev = rects[rects.length - 1];
        const left = Math.min(prev.left, r.left);
        const right = Math.max(prev.right, r.right);
        rects[rects.length - 1] = new DOMRect(
          left,
          prev.top,
          right - left,
          Math.max(prev.height, r.height)
        );
      }
    }
  }

  // Normalisera till containerEl (overlayns koordinatsystem)
  const cont = containerEl.getBoundingClientRect();
  const normalized = rects
    .filter(r => r.width > 0 && r.height > 0)
    .sort((a, b) => a.top - b.top)
    .map(r => new DOMRect(
      r.left - cont.left + containerEl.scrollLeft,  // viktigt
      r.top  - cont.top  + containerEl.scrollTop,   // viktigt
      r.width,
      r.height
    ));

  // Slå ihop splittrade rader på samma top
  const merged: DOMRect[] = [];
  for (const r of normalized) {
    const last = merged[merged.length - 1];
    if (last && Math.abs(last.top - r.top) < 0.5) {
      const left = Math.min(last.left, r.left);
      const right = Math.max(last.left + last.width, r.left + r.width);
      merged[merged.length - 1] = new DOMRect(left, last.top, right - left, Math.max(last.height, r.height));
    } else {
      merged.push(r);
    }
  }
  return merged;
}

2) Anropa den med båda ref:arna och observera båda

Byt ut din mät-effect till:

useEffect(() => {
  if (!textRef.current || !contentRef.current) return;

  const measure = () => {
    if (!textRef.current || !contentRef.current) return;
    try {
      const rects = measureLineRects(textRef.current, contentRef.current);
      setLineRects(rects);
      setCurrentReadingLine(0);
    } catch (error) {
      console.warn("Error measuring line rects:", error);
      setLineRects([]);
      setCurrentReadingLine(0);
    }
  };

  const id = requestAnimationFrame(measure);

  const roText = new ResizeObserver(measure);
  const roCont = new ResizeObserver(measure);
  roText.observe(textRef.current);
  roCont.observe(contentRef.current);

  return () => {
    cancelAnimationFrame(id);
    roText.disconnect();
    roCont.disconnect();
  };
}, [
  lesson,
  currentPage,
  accessibilitySettings.fontSize,
  accessibilitySettings.lineHeight,
  accessibilitySettings.fontFamily,
]);

3) Bredden på fokusrektangeln

Räkna bredden från contentRef (där overlayn ligger), inte från textRef:

const focusRect = useMemo(() => {
  try {
    if (!lineRects.length) return null;
    const start = Math.min(currentReadingLine, Math.max(0, lineRects.length - 1));
    const end = Math.min(start + readingFocusLines - 1, lineRects.length - 1);

    const top = lineRects[start]?.top || 0;
    const bottom = (lineRects[end]?.top || 0) + (lineRects[end]?.height || 0);
    const height = bottom - top;

    if (!contentRef.current) return null;            // <-- ändrat
    const width = contentRef.current.clientWidth;    // <-- ändrat

    return { top, height, left: 0, width };
  } catch {
    return null;
  }
}, [lineRects, currentReadingLine, readingFocusLines]);


Det är allt. När raderna mäts i samma koordinatsystem som overlayn ritas i (container + scroll), kommer “hålet” hamna rätt och masken slutar täcka allt.

Två små observationer

defMap i processContentWithDefinitions skapas men används aldrig – säkert att ta bort.

Din CSS ser ok; problemet ligger inte där utan i koordinat-normaliseringen i JS.

Vill du att jag skickar en minimal patch/diff över endast de rader som ändras i din fil så du kan klistra in rakt av?