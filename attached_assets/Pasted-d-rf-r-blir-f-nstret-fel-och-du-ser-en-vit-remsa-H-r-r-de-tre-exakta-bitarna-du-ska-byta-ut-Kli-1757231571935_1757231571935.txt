därför blir “fönstret” fel och du ser en vit remsa. Här är de tre exakta bitarna du ska byta ut. Klistra in dem rakt av.

1) Byt ut funktionen som mäter raderna
// ⬇️ ersätt HELA din measureLineRects med denna
function measureLineRects(textEl: HTMLElement, containerEl: HTMLElement): DOMRect[] {
  if (!textEl || !containerEl) return [];

  const getAllTextNodes = (root: Node): Text[] => {
    const out: Text[] = [];
    const walker = document.createTreeWalker(root, NodeFilter.SHOW_TEXT, {
      acceptNode: (n) => (/\S/.test(n.nodeValue || "") ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_REJECT),
    });
    let n: Node | null;
    while ((n = walker.nextNode())) out.push(n as Text);
    return out;
  };

  const rects: DOMRect[] = [];
  const textNodes = getAllTextNodes(textEl);
  if (!textNodes.length) return [];

  const range = document.createRange();
  for (const tn of textNodes) {
    let lastTop: number | null = null;
    for (let i = 0; i < tn.length; i++) {
      range.setStart(tn, i);
      range.setEnd(tn, i + 1);
      const r = range.getClientRects()[0];
      if (!r || r.width === 0 || r.height === 0) continue;

      if (lastTop === null || Math.abs(r.top - lastTop) > 0.5) {
        rects.push(r);
        lastTop = r.top;
      } else {
        const prev = rects[rects.length - 1];
        const left = Math.min(prev.left, r.left);
        const right = Math.max(prev.right, r.right);
        rects[rects.length - 1] = new DOMRect(left, prev.top, right - left, Math.max(prev.height, r.height));
      }
    }
  }

  // normalisera till container + ta hänsyn till scroll
  const cont = containerEl.getBoundingClientRect();
  const normalized = rects
    .filter((r) => r.height > 0 && r.width > 0)
    .sort((a, b) => a.top - b.top)
    .map(
      (r) =>
        new DOMRect(
          r.left - cont.left + containerEl.scrollLeft,
          r.top - cont.top + containerEl.scrollTop,
          r.width,
          r.height
        )
    );

  // slå ihop delar som ligger på samma rad
  const merged: DOMRect[] = [];
  for (const r of normalized) {
    const last = merged[merged.length - 1];
    if (last && Math.abs(last.top - r.top) < 0.5) {
      const left = Math.min(last.left, r.left);
      const right = Math.max(last.left + last.width, r.left + r.width);
      merged[merged.length - 1] = new DOMRect(left, last.top, right - left, Math.max(last.height, r.height));
    } else {
      merged.push(r);
    }
  }
  return merged;
}

2) Mät-effekten ska observera både texten och containern
// ⬇️ ersätt din useEffect som "mäter rader" med denna
useEffect(() => {
  const measure = () => {
    if (!textRef.current || !contentRef.current) return;
    try {
      const rects = measureLineRects(textRef.current, contentRef.current);
      setLineRects(rects);
      setCurrentReadingLine(0);
    } catch (err) {
      console.warn("Error measuring line rects:", err);
      setLineRects([]);
      setCurrentReadingLine(0);
    }
  };

  // mät på nästa tick
  const raf = requestAnimationFrame(measure);

  // reagera på resize för BÅDA
  const roText = new ResizeObserver(measure);
  const roCont = new ResizeObserver(measure);
  if (textRef.current) roText.observe(textRef.current);
  if (contentRef.current) roCont.observe(contentRef.current);

  // uppdatera på scroll i containern (viktigt vid fokusflytt)
  const onScroll = () => measure();
  contentRef.current?.addEventListener("scroll", onScroll, { passive: true });

  return () => {
    cancelAnimationFrame(raf);
    roText.disconnect();
    roCont.disconnect();
    contentRef.current?.removeEventListener("scroll", onScroll);
  };
}, [
  lesson,
  currentPage,
  accessibilitySettings.fontSize,
  accessibilitySettings.lineHeight,
  accessibilitySettings.fontFamily,
]);

3) focusRect ska använda bredden från containern
// ⬇️ ersätt din useMemo för focusRect med denna
const focusRect = useMemo(() => {
  try {
    if (!lineRects.length) return null;

    const start = Math.min(currentReadingLine, Math.max(0, lineRects.length - 1));
    const end = Math.min(start + readingFocusLines - 1, lineRects.length - 1);

    const top = lineRects[start]?.top || 0;
    const bottom = (lineRects[end]?.top || 0) + (lineRects[end]?.height || 0);
    const height = bottom - top;

    if (!contentRef.current) return null;
    const width = contentRef.current.clientWidth; // bredden på fönstret där overlayn ligger

    return { top, height, left: 0, width };
  } catch (e) {
    console.warn("Error calculating focus rect:", e);
    return null;
  }
}, [lineRects, currentReadingLine, readingFocusLines]);

Varför detta löser din vita remsa

Din tidigare normalisering saknade scrollTop/scrollLeft och använde bara textRef som referens. Då landar luckan mellan de svarta maskerna på fel Y-position → du ser bara kortets vita bakgrund i stället för texten.

Med koden ovan beräknas varje rad i containerns koordinater + scroll, och fokusfönstret får rätt bredd från containern. Resultatet: den öppna remsan ligger exakt över text-raden.

Snabb checklista efter bytet

Spara/bygg om.

Växla fokusläge på/av en gång.

Prova att ändra fontstorlek/line-height – fönstret ska följa med.

Scrolla i texten – fönstret ska ligga rätt utan att hoppa.

Om något fortfarande ser knäppt ut efter detta, skicka en ny skärmdump + (gärna) din nya measureLineRects, så pinpointar vi nästa 1-2 rader.

7

ChatGPT kan begå misstag. Kontrollera viktig information.