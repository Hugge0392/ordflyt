Japp – du kan få hela skärmen att mörkna i fokusläget. Tricket är att rita dina fyra “scrims” som fixed-lager som täcker viewporten och göra “hålet” (spotlighten) på rätt plats i viewport-koordinater, inte bara i kortet.

Här är den minsta ändringen:

1) Räkna ut spotlight-rektangeln i viewport-koordinater

Lägg till detta useMemo direkt under ditt nuvarande focusRect:

// Fokusrektangel i viewport-koordinater (för global overlay)
const viewportFocusRect = useMemo(() => {
  if (!focusRect || !contentRef.current) return null;
  const cont = contentRef.current.getBoundingClientRect();
  return {
    top: cont.top + focusRect.top,
    left: cont.left + focusRect.left,
    width: focusRect.width,
    height: focusRect.height,
  };
}, [focusRect, readingFocusMode, contentRef.current]);

2) Rita en global overlay (fixed) som täcker hela sidan

Precis efter dina nuvarande (lokala) scrims – eller i stället för dem – lägg till detta block:

{readingFocusMode && viewportFocusRect && (
  <div aria-hidden>
    {/* Global overlay som täcker hela viewporten */}
    <div
      className="rf-global"
      style={{
        position: "fixed",
        inset: 0,
        pointerEvents: "none",
        zIndex: 2147483646, // över allt
      }}
    >
      {/* TOP */}
      <div
        className="rf-scrim"
        style={{
          position: "fixed",
          top: 0,
          left: 0,
          right: 0,
          height: `${viewportFocusRect.top}px`,
        }}
      />
      {/* BOTTOM */}
      <div
        className="rf-scrim"
        style={{
          position: "fixed",
          top: `${viewportFocusRect.top + viewportFocusRect.height}px`,
          left: 0,
          right: 0,
          bottom: 0,
        }}
      />
      {/* LEFT */}
      <div
        className="rf-scrim"
        style={{
          position: "fixed",
          top: `${viewportFocusRect.top}px`,
          left: 0,
          width: `${viewportFocusRect.left}px`,
          height: `${viewportFocusRect.height}px`,
        }}
      />
      {/* RIGHT */}
      <div
        className="rf-scrim"
        style={{
          position: "fixed",
          top: `${viewportFocusRect.top}px`,
          left: `${viewportFocusRect.left + viewportFocusRect.width}px`,
          right: 0,
          height: `${viewportFocusRect.height}px`,
        }}
      />
      {/* FRAME runt hålet (valfritt) */}
      <div
        className="rf-frame"
        style={{
          position: "fixed",
          top: `${viewportFocusRect.top}px`,
          left: `${viewportFocusRect.left}px`,
          width: `${viewportFocusRect.width}px`,
          height: `${viewportFocusRect.height}px`,
          pointerEvents: "none",
          zIndex: 2147483647,
        }}
      />
    </div>
  </div>
)}


Du kan då ta bort de tidigare “lokala” scrimsen inne i .reading-content (de fyra absolut-positionerade), eftersom den här globala overlayn ersätter dem.

3) Lås sidscroll i fokusläge (känns bättre)
useEffect(() => {
  if (readingFocusMode) {
    const prev = document.body.style.overflow;
    document.body.style.overflow = "hidden";
    return () => { document.body.style.overflow = prev; };
  }
}, [readingFocusMode]);

4) Små CSS-regler (du har nästan allt redan)

Behåll dina .rf-scrim/.rf-frame men låt dem funka både lokalt och globalt:

/* Mörkläggning */
.rf-scrim {
  background: rgba(0,0,0,0.86) !important;
  pointer-events: none !important;
}

/* Kant runt läsfönstret */
.rf-frame {
  border: 2px solid var(--accessibility-text-color) !important;
  border-radius: 4px !important;
  background: transparent !important;
}

/* Se till att din close-knapp har högre z-index än scrimsen */
.focus-close-btn { z-index: 2147483648 !important; }


(Ge din befintliga “Avsluta fokus”-knapp klassen focus-close-btn eller sätt ett högre z-index på den.)