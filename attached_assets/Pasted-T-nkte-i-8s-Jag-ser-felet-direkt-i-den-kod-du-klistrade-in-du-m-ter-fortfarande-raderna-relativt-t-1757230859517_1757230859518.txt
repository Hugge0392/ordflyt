Tänkte i 8s

Jag ser felet direkt i den kod du klistrade in: du mäter fortfarande raderna relativt textRef och ritar overlayn relativt contentRef. Då blir topp- och höjdpositionerna fel (padding + scroll missas), och masken täcker nästan allt.

Här får du en minimal patch (kopiera in rakt av). Den gör tre saker:

Mäter rader med både textRef och contentRef och normaliserar till container-koordinater (inkl. scrollTop/scrollLeft).

Anropar mätningen med båda ref:arna och observerar båda.

Räknar fokusrektangelns bredd från contentRef (där overlayn ligger), inte textRef.

1) Byt ut din mätfunktion helt

Ersätt din nuvarande measureLineRects med detta:

function measureLineRects(textEl: HTMLElement, containerEl: HTMLElement): DOMRect[] {
  if (!textEl || !containerEl) return [];

  const rects: DOMRect[] = [];
  const textNodes = getAllTextNodes(textEl);
  if (!textNodes.length) return [];

  const range = document.createRange();

  for (const tn of textNodes) {
    const len = tn.length;
    let lastTop: number | null = null;

    for (let i = 0; i < len; i++) {
      range.setStart(tn, i);
      range.setEnd(tn, i + 1);

      const clientRects = range.getClientRects();
      if (!clientRects?.length) continue;

      const r = clientRects[0];
      if (r.width === 0 || r.height === 0) continue;

      if (lastTop === null || Math.abs(r.top - lastTop) > 0.5) {
        rects.push(r);
        lastTop = r.top;
      } else {
        const prev = rects[rects.length - 1];
        const left = Math.min(prev.left, r.left);
        const right = Math.max(prev.right, r.right);
        rects[rects.length - 1] = new DOMRect(
          left,
          prev.top,
          right - left,
          Math.max(prev.height, r.height)
        );
      }
    }
  }

  // Normalisera till containerEl (där overlayn är absolut-positionerad)
  const cont = containerEl.getBoundingClientRect();
  const normalized = rects
    .filter(r => r.width > 0 && r.height > 0)
    .sort((a, b) => a.top - b.top)
    .map(r => new DOMRect(
      r.left - cont.left + containerEl.scrollLeft,
      r.top  - cont.top  + containerEl.scrollTop,
      r.width,
      r.height
    ));

  // Slå ihop splittrade delar av samma rad
  const merged: DOMRect[] = [];
  for (const r of normalized) {
    const last = merged[merged.length - 1];
    if (last && Math.abs(last.top - r.top) < 0.5) {
      const left = Math.min(last.left, r.left);
      const right = Math.max(last.left + last.width, r.left + r.width);
      merged[merged.length - 1] = new DOMRect(
        left,
        last.top,
        right - left,
        Math.max(last.height, r.height)
      );
    } else {
      merged.push(r);
    }
  }
  return merged;
}

2) Mät med båda ref:arna + observera båda

Ersätt din effekt som startar med // DOM measurement effect - measure lines... med denna:

useEffect(() => {
  if (!textRef.current || !contentRef.current) return;

  const measure = () => {
    if (!textRef.current || !contentRef.current) return;
    try {
      const rects = measureLineRects(textRef.current, contentRef.current);
      setLineRects(rects);
      setCurrentReadingLine(0);
    } catch (error) {
      console.warn("Error measuring line rects:", error);
      setLineRects([]);
      setCurrentReadingLine(0);
    }
  };

  const id = requestAnimationFrame(measure);

  const roText = new ResizeObserver(measure);
  const roCont = new ResizeObserver(measure);
  roText.observe(textRef.current);
  roCont.observe(contentRef.current);

  return () => {
    cancelAnimationFrame(id);
    roText.disconnect();
    roCont.disconnect();
  };
}, [
  lesson,
  currentPage,
  accessibilitySettings.fontSize,
  accessibilitySettings.lineHeight,
  accessibilitySettings.fontFamily,
]);

3) Bredden i focusRect ska komma från container

Ändra din focusRect-memo (bara mittenbiten) så här:

const focusRect = useMemo(() => {
  try {
    if (!lineRects.length) return null;
    const start = Math.min(currentReadingLine, Math.max(0, lineRects.length - 1));
    const end = Math.min(start + readingFocusLines - 1, lineRects.length - 1);
    const top = lineRects[start]?.top || 0;
    const bottom = (lineRects[end]?.top || 0) + (lineRects[end]?.height || 0);
    const height = bottom - top;

    if (!contentRef.current) return null;           // <-- container
    const width = contentRef.current.clientWidth;   // <-- container

    return { top, height, left: 0, width };
  } catch (error) {
    console.warn("Error calculating focus rect:", error);
    return null;
  }
}, [lineRects, currentReadingLine, readingFocusLines]);

Snabb sanity-check (frivilligt)

Lägg dessa två rader temporärt efter att rects satts i mätfunktionen för att se att koordinaterna ser rimliga ut:

console.log("first rect", rects[0]);
console.log("container scroll", containerEl.scrollLeft, containerEl.scrollTop);


Om detta fortfarande inte beter sig som tänkt: skicka gärna ett litet textinnehåll (2–3 korta stycken) som renderas i pages[currentPage] så att jag kan utesluta att det är tomrad/marginkollaps som spökar. Men med patchen ovan ska “hålet” hamna mitt i texten och följa med när du scrollar.